{"version":3,"file":"index.js","sources":["../node_modules/.pnpm/@aicacia+http@https+++codeload.github.com+aicacia+ts-http+tar.gz+b88244d_tslib@2.7.0/node_modules/@aicacia/http/esm/http.js","../src/utils.ts","../src/createWebRTCFetch.ts","../src/createWebRTCServer.ts"],"sourcesContent":["export const DEFAULT_BUFFER_SIZE = 4096;\nexport const HEADER_REGEX = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nexport const HEADER_CONTINUE_REGEX = /^[ \\t]+(.*[^ \\t])/;\nexport const REQUEST_REGEX = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nexport const RESPONSE_REGEX = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\nexport const NEWLINE = \"\\n\".charCodeAt(0);\nexport const RETURN = \"\\r\".charCodeAt(0);\nexport const TEXT_ENCODER = new TextEncoder();\nexport const TEXT_DECODER = new TextDecoder();\nexport class HTTPRequest extends Request {\n    constructor(input, init) {\n        const headersInit = init?.headers;\n        super(input, init);\n        if (headersInit) {\n            const headers = new Headers(headersInit);\n            Object.defineProperty(this, \"headers\", {\n                value: headers,\n                writable: false,\n            });\n        }\n    }\n}\nexport async function parseRequest(reader, init = {\n    mode: \"same-origin\",\n    credentials: \"include\",\n}) {\n    const textReader = createTextReader(reader);\n    const [method, url] = await readRequestStartLine(textReader);\n    const [headers, chunked, contentLength] = await readHeaders(textReader);\n    const body = streamBody(textReader, chunked, contentLength);\n    return new HTTPRequest(url, {\n        ...init,\n        method,\n        headers,\n        body,\n        // @ts-expect-error\n        duplex: \"half\",\n    });\n}\nexport async function parseResponse(reader) {\n    const textReader = createTextReader(reader);\n    const [statusCode, statusText] = await readResponseStartLine(textReader);\n    const [headers, chunked, contentLength] = await readHeaders(textReader);\n    const body = streamBody(textReader, chunked, contentLength);\n    return new Response(body, {\n        status: statusCode,\n        statusText: statusText,\n        headers,\n    });\n}\nexport async function writeRequestOrResponse(writableStream, requestOrResponse) {\n    const writer = writableStream.getWriter();\n    let closed = false;\n    try {\n        const [request, response] = requestOrResponse instanceof Request\n            ? [requestOrResponse, null]\n            : [null, requestOrResponse];\n        if (request) {\n            await writer.write(TEXT_ENCODER.encode(`${request.method} ${request.url} HTTP/1.1\\r\\n`));\n        }\n        else {\n            await writer.write(TEXT_ENCODER.encode(`HTTP/1.1 ${response.status} ${response.statusText}\\r\\n`));\n        }\n        const headers = new Headers(requestOrResponse.headers);\n        if (requestOrResponse.body) {\n            if (request) {\n                const body = await readAll(requestOrResponse.body.getReader());\n                headers.set(\"Content-Length\", `${body.byteLength}`);\n                for (const [key, value] of headers.entries()) {\n                    await writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n                }\n                await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n                await writer.write(body);\n            }\n            else {\n                const contentLength = Number.parseInt(headers.get(\"Content-Length\") || \"0\", 10);\n                const chunked = headers.get(\"Transfer-Encoding\")?.toLowerCase() === \"chunked\";\n                for (const [key, value] of headers.entries()) {\n                    await writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n                }\n                await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n                writer.releaseLock();\n                await streamBody(createTextReader(requestOrResponse.body.getReader()), chunked, contentLength)?.pipeTo(writableStream);\n                closed = true;\n            }\n        }\n        else {\n            for (const [key, value] of headers.entries()) {\n                await writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n            }\n            await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n        }\n    }\n    finally {\n        if (!closed) {\n            writer.releaseLock();\n            writableStream.close();\n        }\n    }\n}\nasync function readRequestStartLine(reader) {\n    const { done, value: startLine } = await reader.readLine();\n    if (done) {\n        throw new Error(\"Unexpected end of request\");\n    }\n    const match = REQUEST_REGEX.exec(startLine);\n    if (!match) {\n        throw new Error(`Invalid request line: ${startLine}`);\n    }\n    return [match[1], match[2], +match[3], +match[4]];\n}\nasync function readResponseStartLine(reader) {\n    const { done, value: startLine } = await reader.readLine();\n    if (done) {\n        throw new Error(\"Unexpected end of request\");\n    }\n    const match = RESPONSE_REGEX.exec(startLine);\n    if (!match) {\n        throw new Error(`Invalid response line: ${startLine}`);\n    }\n    return [+match[3], match[4], +match[1], +match[2]];\n}\nasync function readHeaders(reader) {\n    const headers = new Headers();\n    let chunked = false;\n    let contentLength = 0;\n    while (true) {\n        const { done, value: line } = await reader.readLine();\n        if (done) {\n            throw new Error(\"Unexpected end of headers\");\n        }\n        if (line === \"\") {\n            break;\n        }\n        const match = HEADER_REGEX.exec(line);\n        if (!match) {\n            throw new Error(`Invalid header line: ${line}`);\n        }\n        let value = match[2];\n        while (true) {\n            const continueMatch = HEADER_CONTINUE_REGEX.exec(value);\n            if (!continueMatch) {\n                break;\n            }\n            value = continueMatch[1];\n        }\n        const key = match[1].toLowerCase();\n        if (key === \"transfer-encoding\" && value.toLowerCase() === \"chunked\") {\n            chunked = true;\n        }\n        else if (key === \"content-length\") {\n            contentLength = +value;\n        }\n        headers.append(match[1], value);\n    }\n    return [headers, chunked, contentLength];\n}\nfunction streamBody(reader, chunked, contentLength) {\n    if (!chunked && contentLength === 0) {\n        return null;\n    }\n    const stream = new TransformStream();\n    streamBodyFromReaderToWritable(reader, stream.writable, chunked, contentLength);\n    return stream.readable;\n}\nasync function streamBodyFromReaderToWritable(reader, writableStream, chunked, contentLength) {\n    const writer = writableStream.getWriter();\n    try {\n        if (chunked) {\n            while (true) {\n                const { done, value: line } = await reader.readLine();\n                if (done) {\n                    throw new Error(\"Unexpected end of stream\");\n                }\n                if (HEADER_REGEX.exec(line)) {\n                    await reader.readLine();\n                    break;\n                }\n                const chunkSize = Number.parseInt(line, 16);\n                if (!chunkSize) {\n                    break;\n                }\n                let bytesLeft = chunkSize;\n                while (bytesLeft > 0) {\n                    const { done, value: bytes } = await reader.read(chunkSize);\n                    if (done) {\n                        throw new Error(\"Unexpected end of stream\");\n                    }\n                    bytesLeft -= bytes.byteLength;\n                    await writer.write(bytes);\n                }\n                await reader.readLine();\n            }\n        }\n        else {\n            let bytesLeft = contentLength;\n            while (bytesLeft > 0) {\n                const { done, value: bytes } = await reader.read(bytesLeft);\n                if (done) {\n                    throw new Error(\"Unexpected end of stream\");\n                }\n                bytesLeft -= bytes.byteLength;\n                await writer.write(bytes);\n            }\n        }\n    }\n    finally {\n        reader.releaseLock();\n        writer.releaseLock();\n        writableStream.close();\n    }\n}\nexport function createTextReader(reader, bufferSize = DEFAULT_BUFFER_SIZE) {\n    let buffer = new Uint8Array(bufferSize);\n    let bufferOffset = 0;\n    let bufferLength = 0;\n    let doneReading = false;\n    async function tryFillTo(offset) {\n        if (doneReading) {\n            return offset < bufferLength;\n        }\n        while (offset >= bufferLength) {\n            const { done, value: bytes } = await reader.read();\n            if (done) {\n                doneReading = true;\n                break;\n            }\n            buffer = writeToUint8Array(buffer, bufferLength, bytes);\n            bufferLength += bytes.byteLength;\n        }\n        return offset < bufferLength;\n    }\n    async function readLine() {\n        let index = bufferOffset;\n        let hasData = await tryFillTo(index);\n        while (hasData) {\n            if (buffer[index] === NEWLINE) {\n                const prevIsReturn = buffer[index - 1] === RETURN;\n                const endIndex = prevIsReturn ? index - 1 : index;\n                const line = TEXT_DECODER.decode(buffer.slice(bufferOffset, endIndex));\n                bufferOffset = index + 1;\n                return { done: false, value: line };\n            }\n            index++;\n            if (index >= bufferLength) {\n                hasData = await tryFillTo(index);\n            }\n        }\n        return { done: true };\n    }\n    async function read(byteCount) {\n        const byteLength = bufferOffset + byteCount;\n        await tryFillTo(byteLength - 1);\n        const maxBytesToRead = Math.min(bufferLength - bufferOffset, byteCount);\n        if (maxBytesToRead === 0) {\n            return { done: true };\n        }\n        const bytes = buffer.slice(bufferOffset, bufferOffset + maxBytesToRead);\n        bufferOffset += maxBytesToRead;\n        return { done: false, value: bytes };\n    }\n    function releaseLock() {\n        reader.releaseLock();\n    }\n    return {\n        readLine,\n        read,\n        releaseLock,\n    };\n}\nexport function concatUint8Array(a, b) {\n    const bytes = new Uint8Array(a.byteLength + b.byteLength);\n    bytes.set(a);\n    bytes.set(b, a.byteLength);\n    return bytes;\n}\nexport function writeToUint8Array(buffer, offset, chunk) {\n    if (chunk.byteLength >= buffer.byteLength - offset) {\n        const newBuffer = new Uint8Array(buffer.byteLength * 2);\n        newBuffer.set(buffer);\n        newBuffer.set(chunk, offset);\n        return newBuffer;\n    }\n    buffer.set(chunk, offset);\n    return buffer;\n}\nexport async function readAll(reader) {\n    try {\n        const { done, value: bytes } = await reader.read();\n        if (done) {\n            return new Uint8Array();\n        }\n        let result = bytes;\n        while (true) {\n            const { done, value: bytes } = await reader.read();\n            if (done) {\n                break;\n            }\n            result = concatUint8Array(result, bytes);\n        }\n        return result;\n    }\n    finally {\n        reader.releaseLock();\n    }\n}\n","import { concatUint8Array } from \"@aicacia/http\";\nimport { MAX_INT } from \"@aicacia/rand\";\n\nexport const DEFAULT_MAX_MESSAGE_SIZE = 16384;\nexport const DEFAULT_TIMEOUT_MS = 60_000;\nexport const DEFAULT_BUFFER_SIZE = 4096;\n\nexport function randomUInt32() {\n\treturn (Math.random() * MAX_INT) | 0;\n}\n\nexport function writableStreamFromChannel(\n\tchannel: RTCDataChannel,\n\tidBytes: Uint8Array,\n\tmaxChannelMessageSize: number,\n) {\n\treturn new WritableStream({\n\t\twrite(chunk: Uint8Array) {\n\t\t\twrite(channel, concatUint8Array(idBytes, chunk), maxChannelMessageSize);\n\t\t},\n\t});\n}\n\nexport function write(\n\tchannel: RTCDataChannel,\n\tchunk: Uint8Array,\n\tmaxChannelMessageSize: number,\n) {\n\tif (chunk.byteLength < maxChannelMessageSize) {\n\t\tchannel.send(chunk);\n\t} else {\n\t\tlet offset = 0;\n\t\twhile (offset < chunk.byteLength) {\n\t\t\tconst length = Math.min(maxChannelMessageSize, chunk.byteLength - offset);\n\t\t\tchannel.send(chunk.slice(offset, offset + length));\n\t\t\toffset += length;\n\t\t}\n\t}\n}\n\nexport function bufferedWritableStream(\n\twritableStream: WritableStream<Uint8Array>,\n\tbufferSize = DEFAULT_BUFFER_SIZE,\n): WritableStream<Uint8Array> {\n\tconst buffer = new Uint8Array(bufferSize);\n\tlet bufferOffset = 0;\n\tconst writer = writableStream.getWriter();\n\tasync function write(chunk: Uint8Array) {\n\t\tlet bytesWritten = 0;\n\t\twhile (bytesWritten < chunk.byteLength) {\n\t\t\tif (bufferOffset >= bufferSize) {\n\t\t\t\tawait flush();\n\t\t\t}\n\t\t\tconst length = Math.min(\n\t\t\t\tbufferSize - bufferOffset,\n\t\t\t\tchunk.byteLength - bytesWritten,\n\t\t\t);\n\t\t\tbuffer.set(\n\t\t\t\tchunk.slice(bytesWritten, bytesWritten + length),\n\t\t\t\tbufferOffset,\n\t\t\t);\n\t\t\tbufferOffset += length;\n\t\t\tbytesWritten += length;\n\t\t}\n\t}\n\tasync function flush() {\n\t\tif (bufferOffset > 0) {\n\t\t\tawait writer.write(buffer.slice(0, bufferOffset));\n\t\t\tbufferOffset = 0;\n\t\t}\n\t}\n\treturn new WritableStream({\n\t\twrite,\n\t\tasync close() {\n\t\t\tawait flush();\n\t\t\tawait writer.close();\n\t\t},\n\t});\n}\n","import { bytesToInteger, integerToBytes } from \"@aicacia/hash\";\nimport {\n\tbufferedWritableStream,\n\tDEFAULT_MAX_MESSAGE_SIZE,\n\trandomUInt32,\n\twritableStreamFromChannel,\n} from \"./utils\";\nimport {\n\tHTTPRequest,\n\tparseResponse,\n\twriteRequestOrResponse,\n} from \"@aicacia/http\";\n\ntype Fetch = typeof fetch;\n\nexport type WebRTCFetch = Fetch & {\n\tdestroy(): void;\n};\n\ntype WebRTCConnection = {\n\tidBytes: Uint8Array;\n\tstream: TransformStream;\n\twriter: WritableStreamDefaultWriter<Uint8Array>;\n};\n\nexport function createWebRTCFetch(channel: RTCDataChannel): WebRTCFetch {\n\tconst connections = new Map<number, WebRTCConnection>();\n\n\tfunction createWebRTCConnection() {\n\t\tlet connectionId = randomUInt32();\n\t\twhile (connections.has(connectionId)) {\n\t\t\tconnectionId = randomUInt32();\n\t\t}\n\t\tconst idBytes = integerToBytes(new Uint8Array(4), connectionId);\n\t\tconst stream = new TransformStream();\n\t\tconst connection = {\n\t\t\tidBytes,\n\t\t\tstream,\n\t\t\twriter: stream.writable.getWriter(),\n\t\t};\n\t\tconnections.set(connectionId, connection);\n\t\treturn connection;\n\t}\n\n\tasync function onData(connectionId: number, chunk: Uint8Array) {\n\t\tconst connection = connections.get(connectionId);\n\t\tif (!connection) {\n\t\t\tthrow new Error(`No connection found for id: ${connectionId}`);\n\t\t}\n\t\tawait connection.writer.write(chunk);\n\t}\n\n\tasync function onMessage(event: MessageEvent) {\n\t\tconst chunk = new Uint8Array(event.data);\n\t\tconst connectionId = bytesToInteger(chunk);\n\t\tawait onData(connectionId, chunk.slice(4));\n\t}\n\tchannel.addEventListener(\"message\", onMessage);\n\n\tconst fetch: WebRTCFetch = (input, init) => {\n\t\treturn new Promise<Response>((resolve, reject) => {\n\t\t\tconst request = new HTTPRequest(input, init);\n\t\t\tconst connection = createWebRTCConnection();\n\t\t\tconst writableStream = bufferedWritableStream(\n\t\t\t\twritableStreamFromChannel(\n\t\t\t\t\tchannel,\n\t\t\t\t\tconnection.idBytes,\n\t\t\t\t\tDEFAULT_MAX_MESSAGE_SIZE,\n\t\t\t\t),\n\t\t\t);\n\t\t\twriteRequestOrResponse(writableStream, request)\n\t\t\t\t.then(() =>\n\t\t\t\t\tparseResponse(connection.stream.readable.getReader()).then(resolve),\n\t\t\t\t)\n\t\t\t\t.catch(reject);\n\t\t});\n\t};\n\n\tfetch.destroy = () => channel.removeEventListener(\"message\", onMessage);\n\n\treturn fetch;\n}\n","import { bytesToInteger, integerToBytes } from \"@aicacia/hash\";\nimport { parseRequest, writeRequestOrResponse } from \"@aicacia/http\";\nimport {\n\tbufferedWritableStream,\n\tDEFAULT_MAX_MESSAGE_SIZE,\n\twritableStreamFromChannel,\n} from \"./utils\";\n\ninterface WebRTCConnection {\n\tstream: TransformStream<Uint8Array, Uint8Array>;\n\twriter: WritableStreamDefaultWriter<Uint8Array>;\n}\n\nfunction createWebRTCConnection(): WebRTCConnection {\n\tconst stream = new TransformStream<Uint8Array>();\n\treturn {\n\t\tstream,\n\t\twriter: stream.writable.getWriter(),\n\t};\n}\n\nexport function createWebRTCServer(\n\tchannel: RTCDataChannel,\n\thandler: (request: Request) => Promise<Response> | Response,\n) {\n\tconst connections = new Map<number, WebRTCConnection>();\n\n\tasync function handle(connectionId: number, connection: WebRTCConnection) {\n\t\tconst request = await parseRequest(connection.stream.readable.getReader());\n\t\tconst response = await handler(request);\n\t\tconst writableStream = bufferedWritableStream(\n\t\t\twritableStreamFromChannel(\n\t\t\t\tchannel,\n\t\t\t\tintegerToBytes(new Uint8Array(4), connectionId),\n\t\t\t\tDEFAULT_MAX_MESSAGE_SIZE,\n\t\t\t),\n\t\t);\n\t\tawait writeRequestOrResponse(writableStream, response);\n\t}\n\n\tasync function onData(connectionId: number, chunk: Uint8Array) {\n\t\tlet connection = connections.get(connectionId);\n\t\tif (!connection) {\n\t\t\tconnection = createWebRTCConnection();\n\t\t\tconnections.set(connectionId, connection);\n\t\t\thandle(connectionId, connection);\n\t\t}\n\t\tawait connection.writer.write(chunk);\n\t}\n\n\tasync function onMessage(event: MessageEvent) {\n\t\tconst chunk = new Uint8Array(event.data);\n\t\tconst connectionId = bytesToInteger(chunk);\n\t\tawait onData(connectionId, chunk.slice(4));\n\t}\n\tchannel.addEventListener(\"message\", onMessage);\n\n\treturn () => {\n\t\tchannel.removeEventListener(\"message\", onMessage);\n\t};\n}\n"],"names":["HEADER_REGEX","HEADER_CONTINUE_REGEX","REQUEST_REGEX","RESPONSE_REGEX","NEWLINE","charCodeAt","RETURN","TEXT_ENCODER","TextEncoder","TEXT_DECODER","TextDecoder","HTTPRequest","Request","constructor","input","init","headersInit","headers","super","Headers","Object","defineProperty","this","value","writable","async","parseRequest","reader","mode","credentials","textReader","createTextReader","method","url","done","startLine","readLine","Error","match","exec","readRequestStartLine","chunked","contentLength","readHeaders","body","streamBody","duplex","parseResponse","statusCode","statusText","readResponseStartLine","Response","status","writeRequestOrResponse","writableStream","requestOrResponse","writer","getWriter","closed","request","response","write","encode","bytes","read","Uint8Array","result","concatUint8Array","releaseLock","readAll","getReader","set","byteLength","key","entries","Number","parseInt","get","toLowerCase","pipeTo","close","line","continueMatch","append","stream","TransformStream","chunkSize","bytesLeft","streamBodyFromReaderToWritable","readable","bufferSize","buffer","bufferOffset","bufferLength","doneReading","tryFillTo","offset","writeToUint8Array","index","hasData","endIndex","decode","slice","byteCount","maxBytesToRead","Math","min","a","b","chunk","newBuffer","randomUInt32","random","MAX_INT","writableStreamFromChannel","channel","idBytes","maxChannelMessageSize","WritableStream","send","length","bufferedWritableStream","flush","bytesWritten","createWebRTCFetch","connections","Map","onMessage","event","data","connectionId","bytesToInteger","connection","onData","addEventListener","fetch","Promise","resolve","reject","has","integerToBytes","createWebRTCConnection","then","catch","destroy","removeEventListener","createWebRTCServer","handler","handle"],"mappings":"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","x_google_ignoreList":[0]}